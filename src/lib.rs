#![cfg_attr(
    target_os = "cuda",
    no_std,
    feature(register_attr),
    register_attr(nvvm_internal)
)]

/**
 * Architecture
 * 
 * The size of a block is 384 bytes. The last 16 bytes of the block is the random token
 * that the miner needs to guess. The message block can be constructed ahead of time, and
 * it will consist of 7 chunks. 384*8 happens to be a multiple of 512, so all of the
 * block data including the random guess will be contained in the first 6 chunks.
 * (The last chunk will contain the constant 0b1000_0000 and the original message length).
 * Since the first five chunks do not depend on the random guess, we can initialize the
 * message schedule and hash the first five chunks on the host CPU. When the GPU is
 * ready to take over, the message schedule will have been initialized with the
 * sixth chunk and the hash variables will have been computed for the first
 * five chunks.
 * 
 * Each kernel can then be passed a pointer to the first 12 bytes
 * of the message schedule. Each kernel also receives a pointer to all the random
 * guesses, which are generated by the CPU ahead of time. The kernel must
 * first copy the message schedule to its own memory, then it can substitute a random
 * token and mutate the schedule. Hashing can proceed normally for the sixth chunk.
 * The seventh chunk will always be the same, so the kernel can copy this
 * into the message schedule from constant memory. After hashing the schedule one
 * more time, the kernel can create the hash and put it into the output array.
 */

use cuda_std::prelude::*;
extern crate alloc;

type Schedule = [u32; 64];

const K: [u32; 64] = [
    0b01000010100010100010111110011000,
    0b01110001001101110100010010010001,
    0b10110101110000001111101111001111,
    0b11101001101101011101101110100101,
    0b00111001010101101100001001011011,
    0b01011001111100010001000111110001,
    0b10010010001111111000001010100100,
    0b10101011000111000101111011010101,
    0b11011000000001111010101010011000,
    0b00010010100000110101101100000001,
    0b00100100001100011000010110111110,
    0b01010101000011000111110111000011,
    0b01110010101111100101110101110100,
    0b10000000110111101011000111111110,
    0b10011011110111000000011010100111,
    0b11000001100110111111000101110100,
    0b11100100100110110110100111000001,
    0b11101111101111100100011110000110,
    0b00001111110000011001110111000110,
    0b00100100000011001010000111001100,
    0b00101101111010010010110001101111,
    0b01001010011101001000010010101010,
    0b01011100101100001010100111011100,
    0b01110110111110011000100011011010,
    0b10011000001111100101000101010010,
    0b10101000001100011100011001101101,
    0b10110000000000110010011111001000,
    0b10111111010110010111111111000111,
    0b11000110111000000000101111110011,
    0b11010101101001111001000101000111,
    0b00000110110010100110001101010001,
    0b00010100001010010010100101100111,
    0b00100111101101110000101010000101,
    0b00101110000110110010000100111000,
    0b01001101001011000110110111111100,
    0b01010011001110000000110100010011,
    0b01100101000010100111001101010100,
    0b01110110011010100000101010111011,
    0b10000001110000101100100100101110,
    0b10010010011100100010110010000101,
    0b10100010101111111110100010100001,
    0b10101000000110100110011001001011,
    0b11000010010010111000101101110000,
    0b11000111011011000101000110100011,
    0b11010001100100101110100000011001,
    0b11010110100110010000011000100100,
    0b11110100000011100011010110000101,
    0b00010000011010101010000001110000,
    0b00011001101001001100000100010110,
    0b00011110001101110110110000001000,
    0b00100111010010000111011101001100,
    0b00110100101100001011110010110101,
    0b00111001000111000000110010110011,
    0b01001110110110001010101001001010,
    0b01011011100111001100101001001111,
    0b01101000001011100110111111110011,
    0b01110100100011111000001011101110,
    0b01111000101001010110001101101111,
    0b10000100110010000111100000010100,
    0b10001100110001110000001000001000,
    0b10010000101111101111111111111010,
    0b10100100010100000110110011101011,
    0b10111110111110011010001111110111,
    0b11000110011100010111100011110010,
];

const CHUNK_7: [u32; 16] = [
    0x8000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0000,
    0x0000_0C00
];

#[kernel]
#[allow(improper_ctypes_definitions, clippy::missing_safety_doc)]
pub unsafe fn finish_hash(rand_tokens: &[u8], chunk_6: &[u32; 12], hash_vars: &[u32; 8], hashes: *mut u32) {
    let hash_index = thread::index_1d() as usize;
    let mut schedule: Schedule = [0 as u32; 64];
    let mut hash: [u32; 8] = [0 as u32; 8];

    schedule[0..12].copy_from_slice(chunk_6);
    hash[0..8].copy_from_slice(hash_vars);

    // Guess random number
    let t = hash_index * 16;
    schedule[12] = ((rand_tokens[t] as u32) << 24) | ((rand_tokens[t + 1] as u32) << 16) | ((rand_tokens[t + 2] as u32) << 8) | (rand_tokens[t + 3] as u32);
    schedule[13] = ((rand_tokens[t + 4] as u32) << 24) | ((rand_tokens[t + 5] as u32) << 16) | ((rand_tokens[t + 6] as u32) << 8) | (rand_tokens[t + 7] as u32);
    schedule[14] = ((rand_tokens[t + 8] as u32) << 24) | ((rand_tokens[t + 9] as u32) << 16) | ((rand_tokens[t + 10] as u32) << 8) | (rand_tokens[t + 11] as u32);
    schedule[15] = ((rand_tokens[t + 12] as u32) << 24) | ((rand_tokens[t + 13] as u32) << 16) | ((rand_tokens[t + 14] as u32) << 8) | (rand_tokens[t + 15] as u32);

    // Hash 6th chunk
    let mut a = hash[0];
    let mut b = hash[1];
    let mut c = hash[2];
    let mut d = hash[3];
    let mut e = hash[4];
    let mut f = hash[5];
    let mut g = hash[6];
    let mut h = hash[7];

    for j in 0..48 {
        let w0 = schedule[j];
        let w9 = schedule[j + 9];
        let w1 = schedule[j + 1];
        let s0 = w1.rotate_right(7) ^ w1.rotate_right(18) ^ (w1 >> 3);
        let w14 = schedule[j + 14];
        let s1 = w14.rotate_right(17) ^ w14.rotate_right(19) ^ (w14 >> 10);

        schedule[j + 16] = w0.wrapping_add(s0).wrapping_add(w9).wrapping_add(s1);
    }

    for j in 0..64 {
        let majority = (a & b) ^ (a & c) ^ (b & c);
        let s0 = a.rotate_right(2) ^ a.rotate_right(13) ^ a.rotate_right(22);
        let choice = (e & f) ^ ((!e) & g);
        let s1 = e.rotate_right(6) ^ e.rotate_right(11) ^ e.rotate_right(25);
        let temp2 = s0.wrapping_add(majority);
        let temp1 = h.wrapping_add(s1).wrapping_add(choice).wrapping_add(K[j]).wrapping_add(schedule[j]);

        h = g;
        g = f;
        f = e;
        e = d.wrapping_add(temp1);
        d = c;
        c = b;
        b = a;
        a = temp1.wrapping_add(temp2);
    }

    hash[0] = hash[0].wrapping_add(a);
    hash[1] = hash[1].wrapping_add(b);
    hash[2] = hash[2].wrapping_add(c);
    hash[3] = hash[3].wrapping_add(d);
    hash[4] = hash[4].wrapping_add(e);
    hash[5] = hash[5].wrapping_add(f);
    hash[6] = hash[6].wrapping_add(g);
    hash[7] = hash[7].wrapping_add(h);

    // Hash 7th chunk
    schedule[0..16].copy_from_slice(&CHUNK_7);

    a = hash[0];
    b = hash[1];
    c = hash[2];
    d = hash[3];
    e = hash[4];
    f = hash[5];
    g = hash[6];
    h = hash[7];

    for j in 0..48 {
        let w0 = schedule[j];
        let w9 = schedule[j + 9];
        let w1 = schedule[j + 1];
        let s0 = w1.rotate_right(7) ^ w1.rotate_right(18) ^ (w1 >> 3);
        let w14 = schedule[j + 14];
        let s1 = w14.rotate_right(17) ^ w14.rotate_right(19) ^ (w14 >> 10);

        schedule[j + 16] = w0.wrapping_add(s0).wrapping_add(w9).wrapping_add(s1);
    }

    for j in 0..64 {
        let majority = (a & b) ^ (a & c) ^ (b & c);
        let s0 = a.rotate_right(2) ^ a.rotate_right(13) ^ a.rotate_right(22);
        let choice = (e & f) ^ ((!e) & g);
        let s1 = e.rotate_right(6) ^ e.rotate_right(11) ^ e.rotate_right(25);
        let temp2 = s0.wrapping_add(majority);
        let temp1 = h.wrapping_add(s1).wrapping_add(choice).wrapping_add(K[j]).wrapping_add(schedule[j]);

        h = g;
        g = f;
        f = e;
        e = d.wrapping_add(temp1);
        d = c;
        c = b;
        b = a;
        a = temp1.wrapping_add(temp2);
    }

    *hashes.add(hash_index) = hash[0].wrapping_add(a);
    *hashes.add(hash_index + 1) = hash[1].wrapping_add(b);
    *hashes.add(hash_index + 2) = hash[2].wrapping_add(c);
    *hashes.add(hash_index + 3) = hash[3].wrapping_add(d);
    *hashes.add(hash_index + 4) = hash[4].wrapping_add(e);
    *hashes.add(hash_index + 5) = hash[5].wrapping_add(f);
    *hashes.add(hash_index + 6) = hash[6].wrapping_add(g);
    *hashes.add(hash_index + 7) = hash[7].wrapping_add(h);
}
